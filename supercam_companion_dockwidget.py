# -*- coding: utf-8 -*-
"""
/***************************************************************************
 SupercamCompanionDockWidget
                                 A QGIS plugin
 Helps viewing Supercam science data directly on QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2023-06-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Baptiste Perrier
        email                : baptiste.perrier@ens-lyon.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import numpy as np

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import QgsFeature, QgsPoint

import pyqtgraph as pg

from . import scam_helper as helper

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'supercam_companion_dockwidget_base.ui'))

class SupercamCompanionDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    log = pyqtSignal(str)

    def __init__(self, parent=None):
        """Constructor."""
        super(SupercamCompanionDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
    
    def init(self):
        self.setupUi(self)
        self.current_IRSPlot.setBackground(None)
        self.log.emit("DockWidget instanciated and ready.")

    def mapClicked(self):
        self.current_IRSPlot.clear()
        self.current_IRSPlot.setTitle(None)

        self.spectralParameters_plot.clear()
        self.spectralParameters_plot.setTitle(None)
    
    def ftSelected(self, ft):
        self.currentSelectedFt = ft
        self.name.setText(str(ft.attribute("name")))
        self.time.setText("Sol {}, {} martian time".format(helper.misc.functions.getSolFromsclk(ft.attribute("sclk")), helper.misc.functions.getMartianTimeFromsclk(ft.attribute("sclk"))))
        self.lat.setText(str(QgsPoint(ft.geometry().asPoint()).x()))
        self.lon.setText(str(QgsPoint(ft.geometry().asPoint()).y()))
        self.az.setText("///")
        self.el.setText("///")

        spectralParameters = ft.attribute("VisIRspectralParameters")
        
        if "IRS" in ft.attribute("shots").keys():
            for rowIndex in range(self.spectralParameters_table.rowCount()):
                rowName = self.spectralParameters_table.verticalHeaderItem(rowIndex).text()

                # Mean of spectral parameters
                try:
                    mean = np.mean(spectralParameters[rowName])
                except:
                    mean = "#"
                self.spectralParameters_table.item(rowIndex, 0).setText(str(mean))

                # Median of spectral parameter
                try:
                    median = np.median(spectralParameters[rowName])
                except:
                    median = "#"
                self.spectralParameters_table.item(rowIndex, 1).setText(str(median))

                # Standard Deviation of spectral parameter
                try:
                    std = np.std(spectralParameters[rowName])
                except:
                    std = "#"
                self.spectralParameters_table.item(rowIndex, 2).setText(str(std))
        
            wavelengths, reflectances = helper.science.spectra.getSpectralData(ft.attribute("sclk"), ft.attribute("shots")["IRS"]["cdr_fname"])
            self.current_IRSPlot.setTitle(ft.attribute("name"))
            for reflectance in reflectances:
                self.current_IRSPlot.plot(wavelengths, reflectance, pen=pg.mkPen(color=(200, 200, 200), width=0.5))

            reflectances = np.array(reflectances)
            reflectancesMean = np.mean(reflectances, axis=0)

            self.current_IRSPlot.plot(wavelengths, reflectancesMean, pen=pg.mkPen(color=(0, 0, 125), width=0.5))

            self.current_IRSPlot.plot(wavelengths, helper.science.spectra.getSmoothedSpectrum(reflectancesMean), pen=pg.mkPen(color=(255, 0, 0), width=2))
    
    def updateLocalLastMeasureDisplay(self):
        config = helper.files.local.readLocalConfig()
        self.localLastMeasure_Label.setText("Sol {}, {} Mars. time".format(helper.misc.functions.getSolFromsclk(config["PDSSyncing"]["local_last_sclk"]), helper.misc.functions.getMartianTimeFromsclk(config["PDSSyncing"]["local_last_sclk"])))

    def plotSpectralParameters(self):
        selectedCells = self.spectralParameters_table.selectedIndexes()
        selectedRows = []
        for cell in selectedCells:
            if cell.row() not in selectedRows:
                selectedRows.append(cell.row())

        if len(selectedRows) == 2:
            self.spectralParameters_plot.clear()

            xName = str(self.spectralParameters_table.verticalHeaderItem(selectedRows[0]).text())
            yName = str(self.spectralParameters_table.verticalHeaderItem(selectedRows[1]).text())

            self.current_IRSPlot.setTitle(xName + " / " + yName)

            self.spectralParameters_plot.plot(self.currentSelectedFt.attribute("VisIRspectralParameters")[xName], self.currentSelectedFt.attribute("VisIRspectralParameters")[yName], pen=pg.mkPen(color=(0, 0, 0), width=0), symbol="+")
        else:
            self.log.emit("You must select 2 parameters to plot !")
            self.log.emit(str(selectedCells))

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()
